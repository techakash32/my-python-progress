'''
====================================================================
üìå PYTHON MRO (METHOD RESOLUTION ORDER) ‚Äî NOTES + EXAMPLES + COMMENTS
====================================================================

DEFINITION:
-----------
MRO (Method Resolution Order) is the order in which Python searches
for a method or variable in a class inheritance hierarchy.

In simple words:
‚û° When you call an object.method(), Python follows a fixed order
   to find that method in parent classes.

WHY DO WE NEED MRO?
-------------------
‚úî To avoid confusion in multiple inheritance  
‚úî To solve the ‚Äúdiamond problem‚Äù  
‚úî To ensure predictable and consistent method lookup  
‚úî To know which parent method Python will call  
‚úî To maintain clean inheritance rules  

Python internally uses the **C3 Linearization Algorithm** to calculate MRO.

====================================================================
# HOW TO CHECK MRO?
# ---------------------------------------------------------------
1Ô∏è‚É£ ClassName.__mro__  
2Ô∏è‚É£ ClassName.mro()  
====================================================================
"""

# Example:
class A: pass
class B(A): pass
class C(B): pass

print(C.mro())   # Shows MRO order: [C, B, A, object]


print("------------------------------------------------------------")
"""
====================================================================
# 1Ô∏è‚É£ SINGLE INHERITANCE MRO
# ---------------------------------------------------------------
RULE:
Child ‚Üí Parent ‚Üí object

Simplest form of inheritance.
====================================================================
"""

class A:
    def show(self):
        print("Class A method")

class B(A):  # B inherits A
    pass

b = B()
b.show()    # Class A method (found in parent)

print(B.mro())  # [B, A, object]


print("------------------------------------------------------------")
"""
====================================================================
# 2Ô∏è‚É£ MULTIPLE INHERITANCE MRO
# ---------------------------------------------------------------
RULE:
Left Parent ‚Üí Right Parent ‚Üí Grandparents ‚Üí object

Python uses C3 Linearization:
‚úî Left parent is checked first
‚úî Then right parent
‚úî No class appears twice
====================================================================
"""

class A:
    def show(self):
        print("A class method")

class B:
    def show(self):
        print("B class method")

class C(A, B):   # Multiple inheritance
    pass

c = C()
c.show()        # A class method (because A is first in MRO)

print(C.mro())  # [C, A, B, object]


print("------------------------------------------------------------")
"""
====================================================================
# 3Ô∏è‚É£ DIAMOND PROBLEM (MRO SOLVES IT)
# ---------------------------------------------------------------
Structure:

        A
       / \
      B   C
       \ /
        D

Both B and C inherit A.  
D inherits B and C.

Which show() should D call?
‚û° Python follows MRO to decide.
====================================================================
"""

class A:
    def show(self):
        print("A method")

class B(A):
    pass

class C(A):
    def show(self):
        print("C method")   # Overrides A

class D(B, C):  # Diamond shape
    pass

d = D()
d.show()       # C method (MRO chooses C before A)

print(D.mro())  # [D, B, C, A, object]


print("------------------------------------------------------------")
"""
====================================================================
SUMMARY OF MRO
====================================================================

‚úî MRO determines how Python searches for methods/variables.

‚úî Python uses:
   ‚Üí C3 Linearization Algorithm  
   ‚Üí Left-to-right rule  
   ‚Üí No repeated classes  

‚úî Use:
   ‚Üí Class.mro()  
   ‚Üí Class.__mro__  

‚úî MRO helps in:
   ‚Ä¢ Multiple inheritance  
   ‚Ä¢ Removing confusion  
   ‚Ä¢ Predictable method lookup  
   ‚Ä¢ Avoiding ambiguity in diamond inheritance  

END OF NOTES.
"""

'''